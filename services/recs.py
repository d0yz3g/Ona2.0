import os
import logging
import asyncio
import httpx
from typing import Dict, Any, Optional
from openai import AsyncOpenAI

# Настройка логирования
logger = logging.getLogger(__name__)

# Проверка наличия API-ключа OpenAI
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    logger.warning("OPENAI_API_KEY не найден в переменных окружения. Будет использован режим заглушки.")

# Инициализация клиента OpenAI с API-ключом из переменных окружения (если доступен)
http_client = httpx.AsyncClient()
client = None
if OPENAI_API_KEY:
    try:
        client = AsyncOpenAI(
            api_key=OPENAI_API_KEY,
            http_client=http_client
        )
    except Exception as e:
        logger.error(f"Ошибка при инициализации OpenAI API: {e}")

# Список доступных фокусов для рекомендаций
AVAILABLE_FOCUSES = {
    "burnout": "эмоциональным выгоранием",
    "anxiety": "тревогой",
    "depression": "депрессией",
    "stress": "стрессом",
    "postpartum": "послеродовым периодом",
    "self-esteem": "низкой самооценкой",
    "grief": "горем и утратой",
    "relationship": "отношениями",
    "family": "семейными проблемами",
    "career": "карьерными вопросами",
    "motivation": "мотивацией",
    "sleep": "проблемами сна",
    "default": "повседневными трудностями"
}

# Заготовленные рекомендации для режима без OpenAI API
DEFAULT_RECOMMENDATIONS = {
    "burnout": "Важно распределить нагрузку и выделить время для отдыха. Попробуйте технику Помодоро — 25 минут работы, 5 минут отдыха.",
    "anxiety": "Попробуйте дыхательную технику 4-7-8: вдох на 4 счета, задержка на 7, выдох на 8. Регулярная физическая активность также значительно снижает тревожность.",
    "depression": "Составьте список маленьких дел, которые приносят вам радость, и выполняйте хотя бы одно каждый день. Общение с близкими также может улучшить состояние.",
    "stress": "Регулярные перерывы в работе помогут снизить стресс. Попробуйте медитацию или прогулку на свежем воздухе хотя бы 15 минут в день.",
    "postpartum": "Важно принять помощь близких и не стесняться просить о ней. Выделите время для себя, даже 15-20 минут могут значительно улучшить ваше состояние.",
    "self-esteem": "Ведите дневник достижений, записывая даже небольшие успехи. Избегайте сравнения себя с другими, фокусируйтесь на своем прогрессе.",
    "grief": "Дайте себе разрешение скорбеть столько, сколько нужно. Не подавляйте эмоции, поговорите о них с близкими или специалистом.",
    "relationship": "Эффективная коммуникация — ключ к здоровым отношениям. Говорите о своих чувствах, используя «я-высказывания» вместо обвинений.",
    "family": "Установите четкие границы и правила, которые работают для всех членов семьи. Выделите время для семейных активностей без гаджетов.",
    "career": "Определите свои профессиональные цели на ближайшие 3-6 месяцев. Инвестируйте время в развитие навыков, которые для них необходимы.",
    "motivation": "Разбейте большие задачи на более мелкие и достижимые. Отмечайте прогресс и награждайте себя за выполненные шаги.",
    "sleep": "Создайте вечерний ритуал без гаджетов за час до сна. Следите за регулярностью времени отхода ко сну и пробуждения.",
    "default": "Практикуйте осознанность и внимательность к своим эмоциям. Выделите время на деятельность, которая приносит вам удовольствие и помогает расслабиться."
}

# Словарь для хранения последнего времени запроса пользователя
last_request_time: Dict[int, float] = {}

async def generate_recommendation(text: str, user_id: int, focus: str = "default") -> str:
    """
    Генерация персонализированной рекомендации для пользователя с использованием OpenAI.
    Если OpenAI API недоступен, возвращает заготовленную рекомендацию.
    
    Args:
        text: Текст сообщения пользователя.
        user_id: ID пользователя в Telegram.
        focus: Фокус рекомендации (burnout, anxiety, postpartum и т.д.).
        
    Returns:
        str: Сгенерированная рекомендация.
    """
    # Проверка наличия антиспам-защиты
    current_time = asyncio.get_event_loop().time()
    if user_id in last_request_time:
        time_diff = current_time - last_request_time[user_id]
        if time_diff < 5:  # Не чаще одного раза в 5 секунд
            wait_time = round(5 - time_diff, 1)
            return f"Пожалуйста, подождите {wait_time} сек. перед следующим запросом."
    
    # Обновляем время последнего запроса
    last_request_time[user_id] = current_time
    
    # Нормализуем фокус
    normalized_focus = focus.lower()
    if normalized_focus not in AVAILABLE_FOCUSES:
        normalized_focus = "default"
    
    # Если API-ключ OpenAI не настроен или клиент не инициализирован, используем заготовленные рекомендации
    if not client:
        return DEFAULT_RECOMMENDATIONS.get(normalized_focus, DEFAULT_RECOMMENDATIONS["default"])
    
    # Получаем текстовое описание фокуса
    focus_description = AVAILABLE_FOCUSES[normalized_focus]
    
    try:
        # Создаем запрос к OpenAI
        response = await client.chat.completions.create(
            model="gpt-3.5-turbo",  # Можно заменить на gpt-4, если доступен
            temperature=0.7,
            messages=[
                {
                    "role": "system",
                    "content": f"Ты — профессиональный психолог. Дай 1–2 коротких, практических совета для клиента с фокусом: {focus_description}. Ответ должен быть на русском языке, не более 3-4 предложений, без введения и заключения."
                },
                {
                    "role": "user",
                    "content": text
                }
            ]
        )
        
        # Получаем результат
        result = response.choices[0].message.content.strip()
        logger.info(f"Сгенерирована рекомендация для пользователя {user_id} с фокусом '{normalized_focus}'")
        
        return result
        
    except Exception as e:
        logger.error(f"Ошибка при генерации рекомендации: {e}")
        # В случае ошибки также возвращаем заготовленную рекомендацию
        return DEFAULT_RECOMMENDATIONS.get(normalized_focus, DEFAULT_RECOMMENDATIONS["default"])

def detect_focus(text: str) -> Optional[str]:
    """
    Определяет фокус рекомендации на основе текста пользователя.
    
    Args:
        text: Текст сообщения пользователя.
        
    Returns:
        Optional[str]: Фокус рекомендации или None, если фокус не определен.
    """
    text_lower = text.lower()
    
    focus_keywords = {
        "burnout": ["выгорание", "выгорел", "устал", "истощение", "нет сил", "перегрузк"],
        "anxiety": ["тревога", "тревожность", "паник", "волнение", "беспокойств", "страх"],
        "depression": ["депресси", "подавлен", "грусть", "тоска", "печаль", "апатия", "нет настроения"],
        "stress": ["стресс", "напряжение", "нервы", "нервничаю", "давление"],
        "postpartum": ["после родов", "послеродов", "ребенок", "малыш", "грудное", "кормление"],
        "self-esteem": ["самооценка", "неуверенность", "комплекс", "не справляюсь", "недостаточно"],
        "grief": ["горе", "потеря", "утрата", "умер", "смерть", "скорбь"],
        "relationship": ["отношения", "партнер", "муж", "жена", "расстался", "любовь", "измена"],
        "family": ["семья", "родители", "дети", "мама", "папа", "ребенок", "конфликт"],
        "career": ["работа", "карьера", "должность", "профессия", "увольнение", "коллеги"],
        "motivation": ["мотивация", "лень", "прокрастинация", "откладываю", "не могу начать"],
        "sleep": ["сон", "бессонница", "не спится", "просыпаюсь", "недосып"]
    }
    
    for focus, keywords in focus_keywords.items():
        for keyword in keywords:
            if keyword in text_lower:
                return focus
    
    return None 